## API Report File for "@acidic/engine"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AstNode } from 'langium';
import { AstNode as AstNode_2 } from 'langium/lib/syntax-tree';
import { CompilerOptions } from 'ts-morph';
import { ErrorCode } from '@storm-stack/errors';
import { ESLint } from 'eslint';
import * as Handlebars from 'handlebars';
import { HelperOptions } from 'handlebars/runtime';
import { MaybePromise } from '@storm-stack/utilities';
import { PackageManagers } from '@storm-stack/file-system';
import prettier from 'prettier';
import { Project } from 'ts-morph';
import { Reference } from 'langium';
import { StormConfig } from '@storm-software/config-tools';
import { StormError } from '@storm-stack/errors';
import { StormLog } from '@storm-stack/logging';

// @public (undocumented)
class AcidicEngine {
    // (undocumented)
    static create(config: AcidicConfig, logger: StormLog): AcidicEngine;
    // (undocumented)
    execute: (options: AcidicEngineOptions) => Promise<StormError | Context>;
    // (undocumented)
    generate: (context: Context) => Promise<StormError | Array<{
        plugin: string;
        error: Error;
    }>>;
    // (undocumented)
    readonly outputPath: string;
    // (undocumented)
    prepare: (options: AcidicEngineOptions) => Promise<StormError | Context>;
    // (undocumented)
    readonly version: string;
}
export { AcidicEngine }
export { AcidicEngine as AcidicEngine_alias_1 }

// @public (undocumented)
interface AcidicEngineOptions {
    // (undocumented)
    outputPath?: string;
    // (undocumented)
    packageManager?: PackageManagers;
    // (undocumented)
    schema: string | Model | ServiceSchema;
}
export { AcidicEngineOptions }
export { AcidicEngineOptions as AcidicEngineOptions_alias_1 }

// @public (undocumented)
type AcidicErrorCode = ErrorCode | "missing_schema" | "invalid_schema" | "invalid_schema_extension" | "codegen_failure" | "plugin_not_found" | "invalid_plugin" | "invalid_attr_arg" | "invalid_relationship";

// @public (undocumented)
const AcidicErrorCode: {
    missing_schema: AcidicErrorCode;
    invalid_schema: AcidicErrorCode;
    invalid_schema_extension: AcidicErrorCode;
    codegen_failure: AcidicErrorCode;
    plugin_not_found: AcidicErrorCode;
    invalid_plugin: AcidicErrorCode;
    invalid_attr_arg: AcidicErrorCode;
    invalid_relationship: AcidicErrorCode;
    success: ErrorCode;
    missing_issue_code: ErrorCode;
    invalid_config: ErrorCode;
    failed_to_load_file: ErrorCode;
    missing_context: ErrorCode;
    record_not_found: ErrorCode;
    required_field_missing: ErrorCode;
    database_query_error: ErrorCode;
    model_validation_error: ErrorCode;
    field_validation_error: ErrorCode;
    invalid_parameter: ErrorCode;
    invalid_request: ErrorCode;
    type_error: ErrorCode;
    processing_error: ErrorCode;
    internal_server_error: ErrorCode;
    user_not_logged_in: ErrorCode;
    unknown_cause: ErrorCode;
};
export { AcidicErrorCode }
export { AcidicErrorCode as AcidicErrorCode_alias_1 }

// @public (undocumented)
const ALL_OPERATION_KINDS: string[];
export { ALL_OPERATION_KINDS }
export { ALL_OPERATION_KINDS as ALL_OPERATION_KINDS_alias_1 }
export { ALL_OPERATION_KINDS as ALL_OPERATION_KINDS_alias_2 }

// @public
const AUXILIARY_FIELDS: string[];
export { AUXILIARY_FIELDS }
export { AUXILIARY_FIELDS as AUXILIARY_FIELDS_alias_1 }

// @public (undocumented)
type ConnectorType = "mysql" | "mongodb" | "sqlite" | "postgresql" | "postgres" | "sqlserver" | "cockroachdb" | "jdbc:sqlserver";

// @public (undocumented)
const ConnectorType: {
    MYSQL: ConnectorType;
    MONGO_DB: ConnectorType;
    SQLITE: ConnectorType;
    POSTGRESQL: ConnectorType;
    POSTGRES: ConnectorType;
    SQL_SERVER: ConnectorType;
    COCKROACH_DB: ConnectorType;
    JDBC_SQL_SERVER: ConnectorType;
};
export { ConnectorType }
export { ConnectorType as ConnectorType_alias_1 }

// @public (undocumented)
interface Context {
    config: AcidicConfig;
    logger: StormLog;
    plugins: PluginContext;
    schema?: Model;
    schemaPath?: string;
    wrapper: AcidicSchemaWrapper;
}
export { Context }
export { Context as Context_alias_1 }

// @public
const createPluginHandler: <TOptions extends PluginOptions = PluginOptions>(fileName?: string) => PluginHandler<TOptions>;
export { createPluginHandler }
export { createPluginHandler as createPluginHandler_alias_1 }

// @public
const createTemplatePluginHandler: <TOptions extends TemplatePluginOptions = TemplatePluginOptions>(templatePaths: TemplatePluginPaths, filterTemplates?: ((options: TOptions, context: Context, generator: TemplateGenerator<TOptions>, node: NodeSchema | null, templates: Array<TemplateDetails>) => Array<TemplateDetails>) | undefined) => PluginHandler<TOptions>;
export { createTemplatePluginHandler }
export { createTemplatePluginHandler as createTemplatePluginHandler_alias_1 }

// @public
enum CrudFailureReason {
    DATA_VALIDATION_VIOLATION = "DATA_VALIDATION_VIOLATION",
    RESULT_NOT_READABLE = "RESULT_NOT_READABLE"
}
export { CrudFailureReason }
export { CrudFailureReason as CrudFailureReason_alias_1 }

// @public
const DEFAULT_PASSWORD_SALT_LENGTH = 12;
export { DEFAULT_PASSWORD_SALT_LENGTH }
export { DEFAULT_PASSWORD_SALT_LENGTH as DEFAULT_PASSWORD_SALT_LENGTH_alias_1 }

// @public (undocumented)
const DIRECTORY_TRACKER_SYMBOL: unique symbol;
export { DIRECTORY_TRACKER_SYMBOL }
export { DIRECTORY_TRACKER_SYMBOL as DIRECTORY_TRACKER_SYMBOL_alias_1 }

// @public
export class DirectoryTracker {
    // (undocumented)
    get __base(): string;
    constructor(directoryPath: string, _includedExtensions?: string[]);
    // (undocumented)
    addFile: (filePath: string) => void;
    // (undocumented)
    get directoryPath(): string;
    // (undocumented)
    get files(): DirectoryTrackerFile[];
    // (undocumented)
    getIndexFile: (indexFiles?: DirectoryTrackerIndexFile[]) => DirectoryTrackerIndexFile[];
}

// @public (undocumented)
export type DirectoryTrackerFile = {
    fullPath: string;
    name: string;
};

// @public (undocumented)
export type DirectoryTrackerIndexFile = {
    fileContent: string;
    fileName: string;
};

// @public
const ensureOutputFolder: (outputPath?: string) => string | undefined;
export { ensureOutputFolder }
export { ensureOutputFolder as ensureOutputFolder_alias_1 }
export { ensureOutputFolder as ensureOutputFolder_alias_2 }

// @public
abstract class Generator_2<TOptions extends PluginOptions = PluginOptions> implements IGenerator {
    constructor(context: Context);
    // (undocumented)
    abstract get commentStart(): string;
    // (undocumented)
    protected context: Context;
    // (undocumented)
    abstract get fileExtension(): string | "*";
    // (undocumented)
    abstract generate(options: TOptions, node: NodeSchema, context: Context, params: any): Promise<string>;
    // (undocumented)
    protected getFileFooter(options: TOptions): string;
    // (undocumented)
    protected getFileFooterTemplate: (commentStart?: string) => string;
    // (undocumented)
    protected getFileHeader(options: TOptions): string;
    // (undocumented)
    protected getFileHeaderTemplate(name: string, commentStart?: string): string;
    // (undocumented)
    protected abstract innerWrite(options: TOptions, fileContent: string, fileName: string, fileExtension: string): Promise<void>;
    // (undocumented)
    abstract get name(): string;
    // (undocumented)
    abstract save(options: TOptions): Promise<void>;
    // (undocumented)
    write(options: TOptions, fileContent: string, fileName: string, fileExtension?: string): Promise<void>;
}
export { Generator_2 as Generator }
export { Generator_2 as Generator_alias_1 }

// @public (undocumented)
const GENERATOR_SYMBOL: unique symbol;
export { GENERATOR_SYMBOL }
export { GENERATOR_SYMBOL as GENERATOR_SYMBOL_alias_1 }

// @public
function getDefaultOutputFolder(): string | undefined;
export { getDefaultOutputFolder }
export { getDefaultOutputFolder as getDefaultOutputFolder_alias_1 }
export { getDefaultOutputFolder as getDefaultOutputFolder_alias_2 }

// @public (undocumented)
const getGeneratedContent: <TOptions extends TemplatePluginOptions = TemplatePluginOptions>(options: TOptions, context: Context, node: NodeSchema, generator: TemplateGenerator<TOptions>, template: TemplateDetails) => Promise<{
    name: string;
    content: string;
}>;
export { getGeneratedContent }
export { getGeneratedContent as getGeneratedContent_alias_1 }

// @public
function getNodeModulesFolder(startPath?: string): string | undefined;
export { getNodeModulesFolder }
export { getNodeModulesFolder as getNodeModulesFolder_alias_1 }
export { getNodeModulesFolder as getNodeModulesFolder_alias_2 }

// @public (undocumented)
const getTemplates: (context: Context, defaultPath: string | string[], optionsPath?: string | string[]) => Promise<Array<TemplateDetails>>;
export { getTemplates }
export { getTemplates as getTemplates_alias_1 }

// @public (undocumented)
function getVersion(): any;
export { getVersion }
export { getVersion as getVersion_alias_1 }
export { getVersion as getVersion_alias_2 }

// @public
const GUARD_FIELD_NAME = "acidic_guard";
export { GUARD_FIELD_NAME }
export { GUARD_FIELD_NAME as GUARD_FIELD_NAME_alias_1 }

// @public (undocumented)
interface IGenerator<TOptions extends PluginOptions = PluginOptions> {
    // (undocumented)
    generate(options: TOptions, node: NodeSchema, context: Context, params?: any): Promise<string>;
    // (undocumented)
    write(options: TOptions, fileContent: string, fileName: string, fileExtension?: string): Promise<void>;
}
export { IGenerator }
export { IGenerator as IGenerator_alias_1 }

// @public
function isFutureExpr(node: AstNode_2): boolean;
export { isFutureExpr }
export { isFutureExpr as isFutureExpr_alias_1 }
export { isFutureExpr as isFutureExpr_alias_2 }

// @public (undocumented)
const PLUGIN_RUNNER_SYMBOL: unique symbol;
export { PLUGIN_RUNNER_SYMBOL }
export { PLUGIN_RUNNER_SYMBOL as PLUGIN_RUNNER_SYMBOL_alias_1 }

// @public (undocumented)
interface PluginContext {
    current?: string;
    table: WeakMap<PluginContextMapKey, PluginInfo>;
}
export { PluginContext }
export { PluginContext as PluginContext_alias_1 }

// @public (undocumented)
type PluginContextMapKey = Pick<PluginInfo, "options" | "provider">;
export { PluginContextMapKey }
export { PluginContextMapKey as PluginContextMapKey_alias_1 }

// @public (undocumented)
type PluginHandler<TOptions extends PluginOptions = PluginOptions> = (options: TOptions, context: Context, generator: IGenerator<TOptions>) => MaybePromise<void>;
export { PluginHandler }
export { PluginHandler as PluginHandler_alias_1 }

// @public
type PluginHookExtendSchema<TOptions extends PluginOptions = PluginOptions> = (options: TOptions, context: Context) => MaybePromise<ServiceSchema>;
export { PluginHookExtendSchema }
export { PluginHookExtendSchema as PluginHookExtendSchema_alias_1 }

// @public
type PluginHookPostCreateContext<TOptions extends PluginOptions = PluginOptions> = (options: TOptions, context: Context) => MaybePromise<void>;
export { PluginHookPostCreateContext }
export { PluginHookPostCreateContext as PluginHookPostCreateContext_alias_1 }

// @public
type PluginHookPreGenerate<TOptions extends PluginOptions = PluginOptions> = (options: TOptions, context: Context) => MaybePromise<void>;
export { PluginHookPreGenerate }
export { PluginHookPreGenerate as PluginHookPreGenerate_alias_1 }

// @public
type PluginHookPrepareSchema<TOptions extends PluginOptions = PluginOptions> = (options: TOptions, context: Context) => MaybePromise<ServiceSchema>;
export { PluginHookPrepareSchema }
export { PluginHookPrepareSchema as PluginHookPrepareSchema_alias_1 }

// @public (undocumented)
interface PluginHooks<TOptions extends PluginOptions = PluginOptions> {
    extendSchema?: PluginHookExtendSchema<TOptions>;
    postCreateContext?: PluginHookPostCreateContext<TOptions>;
    preGenerate?: PluginHookPreGenerate<TOptions>;
    prepareSchema?: PluginHookPrepareSchema<TOptions>;
}
export { PluginHooks }
export { PluginHooks as PluginHooks_alias_1 }

// @public (undocumented)
type PluginInfo<TOptions extends PluginOptions = PluginOptions> = {
    pluginId: string;
    name: string;
    dependencyOf: string | null;
    provider: string;
    options: TOptions;
    generator?: IGenerator;
    hooks?: PluginHooks<TOptions>;
    handle?: PluginHandler<TOptions>;
    dependencies: PluginInfo<TOptions>[];
    module: PluginModule<TOptions>;
};
export { PluginInfo }
export { PluginInfo as PluginInfo_alias_1 }

// @public
type PluginModule<TOptions extends PluginOptions = PluginOptions> = {
    name?: string;
    options?: TOptions;
    hooks?: PluginHooks<TOptions>;
    generator?: IGenerator<TOptions>;
    execute?: PluginHandler<TOptions>;
    dependencies?: string[];
    resolvedPath: string;
};
export { PluginModule }
export { PluginModule as PluginModule_alias_1 }

// @public
const PRISMA_MINIMUM_VERSION = "4.8.0";
export { PRISMA_MINIMUM_VERSION }
export { PRISMA_MINIMUM_VERSION as PRISMA_MINIMUM_VERSION_alias_1 }

// @public
const PRISMA_PROXY_ENHANCER = "$__acidic_enhancer";
export { PRISMA_PROXY_ENHANCER }
export { PRISMA_PROXY_ENHANCER as PRISMA_PROXY_ENHANCER_alias_1 }

// @public
const PRISMA_TX_FLAG = "$__acidic_tx";
export { PRISMA_TX_FLAG }
export { PRISMA_TX_FLAG as PRISMA_TX_FLAG_alias_1 }

// @public
enum PrismaErrorCode {
    CONSTRAINED_FAILED = "P2004",
    DEPEND_ON_RECORD_NOT_FOUND = "P2025",
    REQUIRED_CONNECTED_RECORD_NOT_FOUND = "P2018",
    UNIQUE_CONSTRAINT_FAILED = "P2002"
}
export { PrismaErrorCode }
export { PrismaErrorCode as PrismaErrorCode_alias_1 }

// @public (undocumented)
const TEMPLATE_EXTENSIONS: string[];
export { TEMPLATE_EXTENSIONS }
export { TEMPLATE_EXTENSIONS as TEMPLATE_EXTENSIONS_alias_1 }

// @public (undocumented)
type TemplateDetails = {
    name: string;
    content: string;
};
export { TemplateDetails }
export { TemplateDetails as TemplateDetails_alias_1 }

// @public
class TemplateGenerator<TOptions extends TemplatePluginOptions = TypescriptPluginOptions> extends TypescriptGenerator<TOptions> {
    constructor(context: Context, config?: TypeScriptGeneratorConfig);
    // (undocumented)
    get fileExtension(): string;
    // (undocumented)
    generate: (options: TOptions, node: NodeSchema, context: Context, params: TemplateDetails) => Promise<string>;
    // (undocumented)
    getContext(): Context;
    // (undocumented)
    getOptions(): TOptions;
    // (undocumented)
    protected getTemplate: (template: TemplateDetails) => Promise<Handlebars.TemplateDelegate>;
    // (undocumented)
    get handlebars(): typeof Handlebars;
    // (undocumented)
    get name(): string;
    // (undocumented)
    protected partials: string[];
    // (undocumented)
    registerHelper: (name: string, helper: TemplateGeneratorHelper) => void;
    // (undocumented)
    registerPartial: (partial: TemplateDetails, name?: string) => void;
    // (undocumented)
    registerPartials: (partials: Array<TemplateDetails>) => Promise<void[]>;
    // (undocumented)
    protected templates: Map<string, Handlebars.TemplateDelegate<any>>;
}
export { TemplateGenerator }
export { TemplateGenerator as TemplateGenerator_alias_1 }

// @public (undocumented)
type TemplateGeneratorHelper = (getContext: () => Context, getOptions: () => TemplatePluginOptions, context?: any, arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, options?: HelperOptions) => any;
export { TemplateGeneratorHelper }
export { TemplateGeneratorHelper as TemplateGeneratorHelper_alias_1 }

// @public
type TemplatePluginOptions = PluginOptions & Partial<TemplatePluginPaths>;
export { TemplatePluginOptions }
export { TemplatePluginOptions as TemplatePluginOptions_alias_1 }

// @public
type TemplatePluginPaths = {
    templatePath?: string | string[];
    partialsPath?: string | string[];
    objectTemplatePath?: string | string[];
    interfaceTemplatePath?: string | string[];
    enumTemplatePath?: string | string[];
    modelTemplatePath?: string | string[];
    eventTemplatePath?: string | string[];
    queryTemplatePath?: string | string[];
    mutationTemplatePath?: string | string[];
    subscriptionTemplatePath?: string | string[];
};
export { TemplatePluginPaths }
export { TemplatePluginPaths as TemplatePluginPaths_alias_1 }

// @public
const TRANSACTION_FIELD_NAME = "acidic_transaction";
export { TRANSACTION_FIELD_NAME }
export { TRANSACTION_FIELD_NAME as TRANSACTION_FIELD_NAME_alias_1 }

// @public
abstract class TypescriptGenerator<TOptions extends TypescriptPluginOptions = TypescriptPluginOptions> extends Generator_2<TOptions> {
    constructor(context: Context, config?: TypeScriptGeneratorConfig);
    // (undocumented)
    get commentStart(): string;
    // (undocumented)
    protected config: TypeScriptGeneratorConfig;
    // (undocumented)
    protected directoryTracker: DirectoryTracker | undefined;
    // (undocumented)
    protected eslint: ESLint;
    // (undocumented)
    get fileExtension(): string;
    // (undocumented)
    protected getParserFromExtension(extension: string): string;
    // (undocumented)
    protected innerWrite(options: TOptions, fileContent: string, fileName: string, fileExtension?: string): Promise<void>;
    // (undocumented)
    protected prettierConfig: prettier.Options;
    // (undocumented)
    protected project: Project;
    // (undocumented)
    save(options: TOptions): Promise<void>;
}
export { TypescriptGenerator }
export { TypescriptGenerator as TypescriptGenerator_alias_1 }

// @public (undocumented)
type TypeScriptGeneratorConfig = {
    compiler?: CompilerOptions;
    eslint?: ESLint.Options;
    prettier?: prettier.Options;
};
export { TypeScriptGeneratorConfig }
export { TypeScriptGeneratorConfig as TypeScriptGeneratorConfig_alias_1 }

// @public
type TypescriptPluginOptions = PluginOptions & {
    compile?: boolean;
    preserveTsFiles?: boolean;
    prettier?: boolean;
    lint?: boolean;
    generateIndexFiles?: boolean;
};
export { TypescriptPluginOptions }
export { TypescriptPluginOptions as TypescriptPluginOptions_alias_1 }

// (No @packageDocumentation comment for this package)

```
